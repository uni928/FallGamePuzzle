<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>落ちゲーパズル - 1分チャレンジ</title>
<style>
  :root{
    --n: 8;
    --cell-size: min(7.5vmin, 56px);
    --gap: 6px;
    --panel: #171b2a;
    --accent: #5cc8ff;
    --ok: #5cd67a;
    --warn: #ffc658;
    --text: #f3f6ff;
    --muted: #aab2c5;
    --fade-ms: 3000; /* 3秒フェード */
  }
  html,body{
    height:100%;
    background: radial-gradient(1200px 600px at 20% -10%, #1b2239, #0d101b 60%, #090b14 100%);
    color: var(--text);
    font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans JP", "Hiragino Kaku Gothic ProN", "Yu Gothic", sans-serif;
    margin:0;
  }
  .wrap{ max-width: min(1000px, 94vw); margin: 24px auto 48px; }
  header{ display:flex; justify-content:space-between; align-items:center; gap: 12px; margin-bottom:16px; }
  header h1{ font-size: clamp(18px, 2.6vmin, 28px); margin:0; }
  .controls{
    display:flex; flex-wrap:wrap; gap: 10px 12px; align-items:center;
    background: color-mix(in oklab, var(--panel) 70%, black);
    padding: 10px 12px; border-radius: 12px; border: 1px solid #2a314a;
  }
  .controls label{ font-size: 13px; color: var(--muted); }
  .controls input[type="number"]{
    width: 64px; padding: 6px 8px; border-radius: 8px;
    border: 1px solid #2a314a; background:#0f1424; color:var(--text);
  }
  .btn{
    appearance:none; border:1px solid #2a314a; background:#0f1424; color:var(--text);
    padding:8px 12px; border-radius:10px; cursor:pointer; font-weight:600;
    transition: transform .04s ease, border-color .15s ease, background .15s ease;
  }
  .btn:hover{ border-color:#3a4263; background:#141a2d; }
  .btn:active{ transform: translateY(1px); }
  .btn.primary{ border-color: color-mix(in oklab, var(--accent), white 12%); background: linear-gradient(180deg, #19334a, #122338); }

  .statbar{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; margin: 10px 0 16px; }
  .pill{
    background: #12182b; border:1px solid #2a314a; border-radius: 999px;
    padding:8px 12px; font-weight:700; letter-spacing:.02em; display:flex; gap:10px; align-items:center;
  }
  .score{ color: var(--ok); } .time{ color: var(--warn); } .best{ color: var(--accent); }
  .bar{ position: relative; width: 220px; height: 10px; border-radius: 999px; overflow:hidden; background: #1a2136; border:1px solid #2a314a; }
  .bar > i{ position:absolute; inset:0 0 0 auto; width: 100%; background: linear-gradient(90deg, #ffcf71, #ff8a71); transition: width .1s linear; }

  .board{
    --side: calc(var(--n) * (var(--cell-size) + var(--gap)) + var(--gap));
    width: var(--side); max-width: 94vw;
    display: grid;
    grid-template-columns: repeat(var(--n), var(--cell-size));
    grid-auto-rows: var(--cell-size);
    gap: var(--gap); padding: var(--gap);
    border-radius: 16px;
    background: linear-gradient(180deg, #13182a, #0c1221);
    border: 1px solid #2a314a;
    box-shadow: 0 10px 40px rgba(0,0,0,.35), inset 0 0 0 1px #10152a;
    margin: 0 auto 12px;
    user-select: none;
  }
  .cell{
    display:flex; align-items:center; justify-content:center;
    border-radius: 10px;
    background: radial-gradient(140% 100% at 50% 0%, #212947, #12182d 70%);
    border: 1px solid #2a314a;
    font-weight: 800; font-size: calc(var(--cell-size) * .42);
    color: #e8efff; text-shadow: 0 1px 0 rgba(0,0,0,.6);
    cursor: pointer; position: relative;
    transition: transform .05s ease, background .15s ease, border-color .15s ease;
    aspect-ratio: 1 / 1;
  }
  .cell:hover{ background:#1a2140; border-color:#3a4263; }
  .cell:active{ transform: translateY(1px) scale(.985); }
  .cell.empty{ background: #0a0f1e; color: transparent; border-color: #1b2138; opacity:.6; }

  /* フェード中（白化→消失）: 対象セルのみクリック不可 */
  .cell.vanish{
    pointer-events: none;
    animation: whiteFade var(--fade-ms)ms ease-in forwards;
    border-color: #8aa3ff;
    box-shadow: 0 0 0 2px rgba(255,255,255,.08) inset, 0 0 24px rgba(200,220,255,.28);
  }
  @keyframes whiteFade{
    0%   { color:#e8efff; background: radial-gradient(140% 100% at 50% 0%, #212947, #12182d 70%); opacity: 1; }
    40%  { color:#ffffff; background: radial-gradient(140% 100% at 50% 0%, #cfd7ff, #e9eeff 70%); opacity: 1; }
    80%  { color:#ffffff; background: radial-gradient(140% 100% at 50% 0%, #ffffff, #ffffff 70%); opacity: .5; }
    100% { color:#ffffff; background: #ffffff; opacity: 0; }
  }

  .overlay{
    position: fixed; inset:0; display:none; place-items:center;
    background: rgba(6, 9, 18, .72); backdrop-filter: blur(4px);
  }
  .overlay .modal{
    background: #10162a; border:1px solid #2a314a; border-radius:16px; padding:20px;
    width: min(480px, 92vw);
    box-shadow: 0 20px 80px rgba(0,0,0,.45);
    text-align:center;
  }
  .modal h2{ margin: 0 0 10px; }
  .rules{
    margin-top: 18px; font-size: 14px; color: var(--muted);
    background: #101628; border:1px solid #2a314a; border-radius:12px; padding:12px 14px;
  }
  .rules code{ background:#0b1020; padding:2px 6px; border-radius:6px; border:1px solid #272f4a; color:#eaf2ff; }
  .tiny{ font-size:12px; color: var(--muted); }
</style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>落ちゲーパズル</h1>
      <div class="controls">
        <label>サイズ:
          <input id="sizeInput" type="number" min="4" max="16" step="1" value="8" />
        </label>
        <button id="newBtn" class="btn primary">新しいゲーム</button>
        <button id="clearBestBtn" class="btn">ベストスコア消去</button>
      </div>
    </header>

    <div class="statbar">
      <div class="pill score">スコア: <b id="score">0</b></div>
      <div class="pill time">残り: <b id="time">60.0</b> 秒</div>
      <div class="pill best">ベスト: <b id="best">0</b></div>
      <div class="bar" title="残り時間"><i id="timeBar" style="width:100%"></i></div>
    </div>

    <div id="board" class="board" aria-label="盤面"></div>

    <div class="rules">
      ・マスをクリックするとそのマスの数字が 1 上がります。(99 の次は 1)<br>
      ・縦横同じ数字で挟むとそれらの数字が3秒後に消えます。<br>
      ・フェード中でも<b>他のマスは操作可能</b>です（フェード中のマスのみ無効）。<br>
      ・フェードは<b>白くなってから消える</b>演出（3秒）。消えたら<b>落下→補充→連鎖判定</b>。
    </div>
  </div>

  <div id="overlay" class="overlay" aria-hidden="true">
    <div class="modal">
      <h2>タイムアップ！</h2>
      <p>最終スコア: <b id="finalScore">0</b></p>
      <p>ベストスコア: <b id="finalBest">0</b></p>
      <div style="display:flex; gap:8px; justify-content:center; margin-top:10px;">
        <button id="retryBtn" class="btn primary">もう一度</button>
        <button id="closeBtn" class="btn">閉じる</button>
      </div>
    </div>
  </div>

<script>
(function(){
  const boardEl = document.getElementById('board');
  const sizeInput = document.getElementById('sizeInput');
  const newBtn = document.getElementById('newBtn');
  const clearBestBtn = document.getElementById('clearBestBtn');

  const scoreEl = document.getElementById('score');
  const timeEl  = document.getElementById('time');
  const timeBar = document.getElementById('timeBar');
  const bestEl  = document.getElementById('best');

  const overlay = document.getElementById('overlay');
  const finalScoreEl = document.getElementById('finalScore');
  const finalBestEl  = document.getElementById('finalBest');
  const retryBtn = document.getElementById('retryBtn');
  const closeBtn = document.getElementById('closeBtn');

  let N = 8;
  let board = [];      // 0=空, 1..9
  let score = 0;
  let best = Number(localStorage.getItem('fallp-best') || 0);
  let started = false;
  let gameOver = false;
  let endTime = 0;
  let rafId = null;

  // ★ フェード中セル集合（"r,c"）
  const fading = new Set();
  // ★ 解決処理の多重起動防止
  let resolving = false;

  bestEl.textContent = best;

  const rnd19 = () => (Math.floor(Math.random() * 99) + 1);
  const clamp = (v,min,max)=> v<min?min:(v>max?max:v);
  const key = (r,c) => `${r},${c}`;
  const sleep = (ms)=> new Promise(res=>setTimeout(res, ms));
  const fadeMS = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--fade-ms')) || 3000;

  function initBoard(){
    board = Array.from({length: N}, () =>
      Array.from({length: N}, () => rnd19())
    );
  }

  function setGridSizeVars(){
    document.documentElement.style.setProperty('--n', String(N));
  }

  function renderBoard(){
    boardEl.innerHTML = '';
    for (let r=0; r<N; r++){
      for (let c=0; c<N; c++){
        const v = board[r][c];
        const cell = document.createElement('div');
        cell.className = 'cell' + (v===0 ? ' empty' : '');
        cell.tabIndex = 0;
        cell.role = "button";
        cell.dataset.r = r;
        cell.dataset.c = c;
        cell.textContent = v===0 ? '' : String(v);
        cell.addEventListener('click', onClickCell);
        cell.addEventListener('keydown', (e)=>{
          if (e.key === 'Enter' || e.key === ' '){ e.preventDefault(); cell.click(); }
        });
        boardEl.appendChild(cell);
      }
    }
  }

  function getCellEl(r,c){ return boardEl.children[r*N + c]; }
  function updateScoreUI(){ scoreEl.textContent = score; }

  function updateTimeUI(){
    const remaining = Math.max(0, endTime - Date.now());
    timeEl.textContent = (remaining / 1000).toFixed(1);
    const pct = remaining / 60000;
    timeBar.style.width = (pct * 100).toFixed(1) + '%';
  }

  function startTimerIfNeeded(){
    if (!started){
      started = true;
      endTime = Date.now() + 60000;
      tick();
    }
  }
  function tick(){
    if (!started) return;
    updateTimeUI();
    if (Date.now() >= endTime){ finishGame(); return; }
    rafId = requestAnimationFrame(tick);
  }
  function finishGame(){
    if (rafId) cancelAnimationFrame(rafId);
    gameOver = true; started = false; updateTimeUI();
    if (score > best){ best = score; localStorage.setItem('fallp-best', String(best)); bestEl.textContent = best; }
    finalScoreEl.textContent = score; finalBestEl.textContent = best;
    overlay.style.display = 'grid'; overlay.setAttribute('aria-hidden', 'false');
  }
  function closeOverlay(){ overlay.style.display='none'; overlay.setAttribute('aria-hidden','true'); }

  function newGame(){
    const v = parseInt(sizeInput.value, 10);
    N = clamp(isFinite(v) ? v : 8, 4, 16);
    sizeInput.value = String(N);
    setGridSizeVars();
    initBoard();
    score = 0; updateScoreUI();
    started = false; gameOver = false;
    if (rafId) cancelAnimationFrame(rafId);
    endTime = Date.now() + 60000;
    timeEl.textContent = '60.0'; timeBar.style.width = '100%';
    fading.clear(); resolving = false;
    renderBoard();
    closeOverlay();
  }

  // クリック（フェード中以外は常に反応）
  async function onClickCell(e){
    if (gameOver) return;
    const r = +e.currentTarget.dataset.r;
    const c = +e.currentTarget.dataset.c;
    // フェード中セルはクリック不能（CSSで無効化済）
    startTimerIfNeeded();

    // 値更新（9→1ループ）
    board[r][c] = (board[r][c] % 99) + 1;
    // 見た目を即時反映（全体再描画せず）
    e.currentTarget.textContent = String(board[r][c]);

    // 解決を試みる（他バッチのフェード進行中は並走せず、終わったらまとめて）
    attemptResolve();
  }

  function attemptResolve(){
    if (resolving) return; // 既に解決中ならスキップ（盤面操作は可能）
    // 少し遅延してから解決（連打の小さな変更をまとめる）
    resolving = true;
    setTimeout(async ()=>{
      await resolveAll();
      resolving = false;
      // まだ挟みが残っていれば続けて処理
      const again = findAllSandwiches(board).segments.length > 0;
      if (again) attemptResolve();
    }, 40);
  }

  // 盤面全解決：見つかった挟みをフェード→消去→落下→再検出
  async function resolveAll(){
    let guard = 0;
    while (true){
      if (guard++ > 100) break;
      const res = findAllSandwiches(board);
      if (res.segments.length === 0) break;

      // スコア加点（ペアの端の値の和）
      const gain = res.segments.reduce((s, seg) => s + seg.value, 0);
      score += gain; updateScoreUI();

      // フェード開始（DOMに.vanish付与 & fading集合に登録）
      for (const k of res.toClear){
        const [r, c] = k.split(',').map(Number);
        fading.add(k);
        const el = getCellEl(r,c);
        if (el && !el.classList.contains('vanish')){
          el.classList.add('vanish');
        }
      }

      // フェード終了待ち
      await sleep(fadeMS);

      // 盤面から削除（0にする）
      for (const k of res.toClear){
        const [r, c] = k.split(',').map(Number);
        board[r][c] = 0;
        fading.delete(k);
      }

      // 落下＆補充 → 全体再描画（このタイミングで.vanish DOMはリセット）
      applyGravityAndRefill();
      renderBoard();
      // 次のループで再検出（連鎖）
    }
  }

  // 横・縦の「同数で挟み」検出（★フェード中セルは0扱い）
  function findAllSandwiches(B){
    const n = B.length;
    const segments = [];
    const toClear = new Set();

    // 行
    for (let r=0; r<n; r++){
      for (let i=0; i<n-2; i++){
        const a = isFading(r,i) ? 0 : B[r][i];
        if (!a) continue;
        for (let j=i+2; j<n; j++){
          const b = isFading(r,j) ? 0 : B[r][j];
          if (b === a){
            segments.push({ value:a, kind:'row', r, i, j });
            for (let c=i; c<=j; c++) toClear.add(key(r,c));
          }
        }
      }
    }
    // 列
    for (let c=0; c<n; c++){
      for (let i=0; i<n-2; i++){
        const a = isFading(i,c) ? 0 : B[i][c];
        if (!a) continue;
        for (let j=i+2; j<n; j++){
          const b = isFading(j,c) ? 0 : B[j][c];
          if (b === a){
            segments.push({ value:a, kind:'col', c, i, j });
            for (let r=i; r<=j; r++) toClear.add(key(r,c));
          }
        }
      }
    }
    return { segments, toClear };
  }

  function isFading(r,c){ return fading.has(key(r,c)); }

  // 落下＆補充（各列独立）
  function applyGravityAndRefill(){
    const n = board.length;
    for (let c=0; c<n; c++){
      const col = [];
      for (let r=0; r<n; r++){
        const v = board[r][c];
        if (v !== 0) col.push(v);
      }
      const holes = n - col.length;
      const newTop = Array.from({length: holes}, () => rnd19());
      const filled = newTop.concat(col);
      for (let r=0; r<n; r++){
        board[r][c] = filled[r];
      }
    }
  }

  // イベント
  newBtn.addEventListener('click', newGame);
  clearBestBtn.addEventListener('click', ()=>{
    localStorage.removeItem('fallp-best');
    best = 0; bestEl.textContent = '0';
  });
  retryBtn.addEventListener('click', ()=>{ newGame(); });
  closeBtn.addEventListener('click', ()=>{ closeOverlay(); });

  // 初期起動
  (function bootstrap(){
    N = clamp(parseInt(sizeInput.value,10)||8, 4, 16);
    sizeInput.value = String(N);
    document.documentElement.style.setProperty('--n', String(N));
    initBoard(); renderBoard(); updateScoreUI();
    timeEl.textContent = '60.0'; timeBar.style.width = '100%';
  })();
})();
</script>
</body>
</html>
